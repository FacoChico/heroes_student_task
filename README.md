# Анализ реализованных алгоритмов

## GeneratePresetImpl — формирование армии противника

### Принцип работы

Алгоритм использует жадную стратегию для создания оптимальной армии компьютера в рамках заданных ограничений.

**Последовательность выполнения:**

1. Приоритизация типов юнитов: метод `getRangedUnitTypes()` упорядочивает доступные типы юнитов по двум критериям:
   - Первичный критерий: отношение урона к стоимости (убывание)
   - Вторичный критерий: отношение здоровья к стоимости (убывание)

2. Заполнение армии: для каждого типа юнитов из упорядоченного списка:
   - Добавляются юниты до достижения лимита (11 единиц на тип) или исчерпания бюджета очков
   - Каждому юниту присваивается уникальное имя и случайная свободная позиция

3. Генерация координат: внутренний класс `PositionGenerator` обеспечивает получение уникальных координат:
   - Инициализируется со всеми доступными позициями (3*21 = 63 клетки)
   - При каждом запросе случайно выбирает и удаляет позицию из списка доступных
   - Гарантирует отсутствие коллизий без необходимости проверок

### Вычислительная сложность

**Анализ сложности:**

- n - число типов юнитов
- m - число юнитов в итоговой армии

- Инициализация структур данных: O(n) (копирование входного списка типов)

- Сортировка типов юнитов: O(n log n) (используется стандартный алгоритм Java)

- Основной цикл формирования армии: O(n + m)
  - Внешний цикл по типам: O(n) итераций
  - Внутренний цикл по количеству: суммарно O(m) итераций (каждая добавляет юнита)
  - Получение координаты через `PositionGenerator.getNextPosition()`: O(1) (удаление из небольшого списка)

**Итог:** O(n) + O(n log n) + O(n + m) = O(n log n + m)

Так как по условию n < m (типов мало, юнитов много), доминирующим членом является O(m).

**Сложность по памяти: O(m)**

- Список итоговой армии: O(m)
- Список упорядоченных типов: O(n) = O(1), так как n фиксировано
- `PositionGenerator`: O(63) = O(1) для хранения доступных позиций


## SimulateBattleImpl — моделирование боевых действий

### Принцип работы

Реализована пошаговая симуляция сражения с соблюдением правил очередности ходов и обработки выбывших юнитов.

**Механизм работы:**

1. Проверка условий продолжения: метод `bothArmiesContainsLivingUnits()` определяет наличие живых юнитов в обеих армиях с использованием Stream API

2. Подготовка к раунду:
   - Для каждой армии вызывается `getOrderedLivingUnits()`:
     - Фильтрация живых юнитов через Stream API: O(n)
     - Сортировка по убыванию атаки: O(n log n)
   - Объединение списков живых юнитов из обеих армий: O(n)
   - Финальная сортировка объединенного списка по убыванию атаки: O(n log n)
   - Результат: единый отсортированный список всех живых юнитов обеих армий

3. Обработка ходов в раунде: последовательная обработка юнитов из объединенного списка:
   - Юниты обрабатываются по очереди независимо от принадлежности к армии
   - Порядок определяется только значением атаки (убывание)
   - Пропуск погибших юнитов (проверка `isAlive()`)
   - Выполнение атаки через `performAttack()`: вызывает `unit.getProgram().attack()` и логирует результат
   - Проверка условий продолжения боя после каждого хода

4. Завершение: симуляция прекращается, когда одна из армий теряет всех живых юнитов

### Вычислительная сложность

**Анализ сложности**

n - число юнитов в обеих армиях

- Цикл раундов: O(R), где R — число раундов
  - Максимум R = O(n), так как минимум один юнит погибает за раунд

- Подготовка к раунду: O(n log n)
  - `getOrderedLivingUnits()` для левой армии: O(n log n)
    - Фильтрация живых юнитов: O(n)
    - Сортировка по убыванию атаки: O(n log n)
  - `getOrderedLivingUnits()` для правой армии: O(n log n)
    - Фильтрация живых юнитов: O(n)
    - Сортировка по убыванию атаки: O(n log n)
  - Объединение списков: O(n)
  - Финальная сортировка объединенного списка: O(n log n)
  - Итого: O(n log n) + O(n log n) + O(n) + O(n log n) = O(n log n)

- Обработка ходов: O(n)
  - Каждый юнит обрабатывается максимум раз за раунд
  - `performAttack()`: O(1), так как `attack()` работает за O(1) по условию
  - Проверка условий продолжения: O(n) (вызов `bothArmiesContainsLivingUnits()`)

**Итог:** O(R) * (O(n log n) + O(n)) = O(n) * O(n log n) = O(n^2 * log n)

**Сложность по памяти: O(n)**

- Списки упорядоченных живых юнитов для каждой армии: O(n)
- Объединенный список всех живых юнитов: O(n)

## SuitableForAttackUnitsFinderImpl — определение доступных целей

### Принцип работы

Алгоритм идентифицирует юнитов, которые не заблокированы другими юнитами и могут быть атакованы.

**Последовательность выполнения:**

1. Построение матрицы препятствий: метод `buildOccupiedPositionsMap()` создает двумерный массив `boolean[][]`:
   - Размер массива: FIELD_WIDTH * FIELD_HEIGHT (27 * 21)
   - `occupiedPositions[x][y] = true` означает, что позиция занята живым юнитом
   - Прямой доступ к массиву обеспечивает O(1) проверку наличия препятствия

2. Извлечение активных юнитов: метод `extractActiveUnits()` собирает все живые юниты в единый список

3. Фильтрация доступных целей: метод `filterAccessibleUnits()` для каждого кандидата вызывает `canBeAttacked()`:
   - Для левой армии (компьютер): проверка препятствий слева (уменьшение координаты X)
   - Для правой армии (игрок): проверка препятствий справа (увеличение координаты X)
   - Проверка выполняется линейным проходом по соответствующему направлению

### Анализ сложности

n - число юнитов в армии

- Инициализация матрицы препятствий: O(n)
  - Проход по всем рядам и юнитам: O(R * U), где R = 3 (константа), U — юнитов в ряду
  - Итого: O(n) операций записи в массив

- Извлечение активных юнитов: O(n)
  - Проход по всем рядам и юнитам: O(n)

- Проверка доступности: O(n * W), где W = 27 (константа)
  - Для каждого из n юнитов проверяем до W позиций в одном направлении
  - Проверка в массиве: O(1)
  - Так как W — константа: O(n * W) = O(n)

**Итог:** O(n) + O(n) + O(n) = O(n)

**Сложность по памяти: O(W * H + n) = O(n)**

- Двумерный массив препятствий: O(W * H) = O(27 * 21) = O(567) = O(1) (константа)
- Список активных юнитов: O(n)
- Список доступных целей: O(n)

## UnitTargetPathFinderImpl — поиск оптимального маршрута

### Принцип работы

Реализован алгоритм BFS для нахождения кратчайшего пути на графе, где вершины — клетки игрового поля, а рёбра — допустимые перемещения (включая диагональные).

**Последовательность выполнения:**

1. Инициализация матрицы препятствий: метод `createObstacleMap()`:
   - Создает двумерный массив `boolean[][]` размером FIELD_WIDTH * FIELD_HEIGHT
   - Помечает позиции живых юнитов как препятствия
   - Исключает стартовую и целевую позиции из препятствий

2. Поиск пути: метод `findShortestRoute()` выполняет BFS:
   - Использует очередь для обхода в ширину
   - Массив `explored[][]` отслеживает посещенные вершины
   - Массив `parentMap[][]` хранит предков для восстановления пути
   - Для каждой вершины проверяет 8 соседних (горизонталь, вертикаль, диагональ)

3. Восстановление маршрута: метод `reconstructPath()`:
   - Начинает от целевой позиции
   - Проходит по цепочке предков до стартовой позиции
   - Разворачивает полученный список для получения пути от старта к цели

### Анализ сложности

W = 27 (ширина игрового поля)
H = 21 (высота игрового поля)
n (число юнитов)

- Создание матрицы препятствий: O(W * H + N)
  - Инициализация массива: O(W * H)
  - Заполнение препятствий (проход по N юнитам): O(N)
  - Так как N < W * H, итого: O(W * H)

- BFS обход: O(W * H)
  - Каждая клетка посещается не более одного раза: O(W * H) вершин
  - Для каждой вершины проверяем 8 соседей: O(8) = O(1)

- Восстановление пути: O(W * H)
  - В худшем случае путь проходит через все клетки: O(W * H)

**Итог:** O(W * H) + O(W * H) + O(W * H) = O(W * H)

**Сложность по памяти: O(W * H)**

- Массив `obstacleMap`: O(W * H)
- Массив `explored`: O(W * H)
- Массив `parentMap`: O(W * H)
- Очередь BFS: O(W * H) в худшем случае (когда все клетки в очереди)
- Список пути: O(W * H) в худшем случае
